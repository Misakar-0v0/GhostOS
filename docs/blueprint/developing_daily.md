# 开发思路流水账

## 2024-04-17

### 关于几种不同的消息类型

+ 作为工业级框架, shell 与 ghost 之间通讯应该有严谨的消息协议. 
  - 要考虑流式协议
+ 和大模型之间通讯, 需要一个大模型的通讯协议. 通常在 openai 的基础上做.
  - 要考虑流式协议
+ 所有的对话历史需要存下来, 通常存到数据库里, 也可以存到文件里. 这里需要一个特殊的协议. 
  - ghost 和 ghost 之间的通讯也要能兼容. 

### 通讯的分层

user => ghost => moos

### 基本的运行原理. 

- 消息会发送给一个 Ghost. 这个框架不需要去开发环境框架. 
- Ghost 会根据对话历史, 把消息分发给不同的任务. 或者它就是专门做任务分发的.
- Ghost 实体的思维就是一个任务树. 每个任务都有 任务上下文 + 对话上下文.
  - 需要实现异步任务. 
- Ghost 的思考过程中调用 LLM. LLM 支持在流式输出里调用 python, 提供一个 moos 给 ghost.
- Ghost 的四种内部交互:
  - 外部用户/环境 和 shell 的交互, shell 和 ghost 的交互. 

### python runtime

需要提供一个 python runtime 给 ghost 运行. ghost 完全用代码的方式驱动自己的思考过程. 这是最难的一个问题. 
解决这个问题后, 整体的生产力就可以有很大的提升. 因为各种各样的逻辑不需要外部建模, 而是通过编程的方式实现. 

需要思考以下各种问题: 
- python runtime 是否是每次可运行的一个脚本. 脚本化似乎会更好控制一些. 
- 脚本化的 python runtime, 可以在一个 thread 内不断地开拓各种数据结构.
- 也需要考虑是不是应该有 meta 能力. ghost 可以在自己的思维(workspace) 里不断创建各种数据对象.
- 临时记忆和持久化记忆很关键. 持久化记忆需要有保存: 
  - 数据结构的定义, 需要保存到 workspace 里. 
  - 数据本身需要存储到某种召回机制里, 方便调用 api 存储和召回. 所以这是两个命题. 
    - 数据存储本身可以视作 index + data, 然后通过各种 api 进行管理. 
- 存储这些数据对象, 和召回它们, 又需要是一个统一的命题. 
  - 对于预编程的 memory, 存取和召回比较简单, 就是对 api 的调用. 
  - 对于动态类型 (临时创建) 的 memory, 则又需要有统一的存储和召回方式.
- python runtime 需要考虑在分布式系统里也可以运行. 意味着运行的栈和变量要可存储. 
  - 如果要可以存储的话, 最好所有的变量都用 pydantic 的方式来保存. 这样只需要保存 类型(包) + variables 就可以还原上下文. 
  - 可以以 task 或者 thread 为基础来存储这些状态. 
- thread 需要滚动存储状态, 如果支持流式输出控制, 则不需要多个上下文
  - 能不能做到流式输出的控制, 需要测试. 
- python runtime 如何销毁? 感觉这里面会涉及到异步任务的调用. 比如多线程. 
  - 初期可以不用做这么高级的 feature. 就把 python runtime 当成一个可运行的状态控制. 
  - 控制 moos 给 ghost 提供的 api, 不要让它干太多的事情. 
- 多线程问题是一个关键的考验. 非阻塞问题是另一个. 
- 我要考虑分布式系统是不是必要的, 如果不是分布式, 就只是一个本地的生产力工具. 否则就需要分布式. 
- 分布式系统的话, 一开始就应该考虑全异步通讯的问题了. 甚至包括 task 也应该是全异步的. 
  - 最好一开始不要把复杂度搞这么高, 会导致启动不了. 可以启动后再逐步解决分布式的问题. 
  - 对于一个 Agent 可以持续学习的系统, 反而不这么依赖复杂的分布式体系. 



## 2024-04-16

1. 设计原型.
2. 实现一个 chat completion 的测试工具. 考虑使用 moonshot 等 cn 的模型来做测试.
  - 好像有一些开源库更适合做测试? 
    - 最好用自己的库. 方便未来做功能, 还可以开源. 但也需要借鉴开源项目, 而且不能做得太复杂了.
    - 自己的库可以作为未来大模型的工具被使用. 

自然语言 interface 的思路: 

```markdown
API:
+ moos: 面向模型的操作系统.
对象: 
+ self: 当前自身可用的 api
  + agents: 
```

API 和对象结合到一起的话, 需要定义几种不同的前缀: 
- `+`: 用来定义模块
- `-`: 用来定义实例, 同时是模块的属性.
- `*`: 用来定义模块的 methods, 但不是实例的. 

实例的数据需要被 moos api 去查看. 看起来 markdown 形式比 yaml 形式表现力更好. 

一个关键的难点是如何定义复杂的参数. 如果一个参数本身又是一个结构体, 这样情况就复杂了. 
不过有一个办法就是让模型和任务之间进行多轮对话. 哈哈哈. 
task 可以要求模型补齐入参所需要的额外信息. 从而和 agent 进行对话. 这样做的缺点是模型经常要重新从上下文里学习. 

未来模型应该可以实现快速学习. 会有比 sft 更合适的 interface.

# 确定的设计

- 流式输出: 以流式输出为基础, 非流式输出无法用于工业环境. 
- 自然语言函数 interface: 用 markdown 表示的自然语言树来定义函数体系, 支持 LLM 调用自然语言函数.
- python runtime: 自然语言函数运行的时候, 使用 python 的运行时. 
  - python 的运行时可能使用脚本进程来实现. 不一定是持久化进程. 
  - ghost runtime 和 python runtime 分开
- shell runtime(?) : 理论上要支持 shell, 但是也不一定吧. 
- 根据对话历史构建脚本: 对话历史 (Thread) 可以用来构建一个可执行的脚本. main 方法可以用 eval 去执行.
  - 对话历史考虑定义成 _chat.yml 文件. 可以被 moos 执行. 

# 确定需要做的 LLM 实验

- 可分段的流式输出. 
- 自然语言函数 interface.
- 基于自然语言调用, 翻译成 python 执行代码. 

# 确定要开发的功能模块

- python runtime. 好像用脚本语言就 ok 了? 但是要支持流式输出. 需要脚本化. 
- ghost runtime. 需要一个持久的进程. 
- shell, 与 ghost 进行通讯.
- 基于文件来构建的知识体系. 
