from __future__ import annotations
from typing import (
    Protocol, Optional, Iterable, TypeVar, Any, Union, Self, ClassVar, Type, Callable, Generic, Dict,
)
from abc import ABC, abstractmethod
from ghostos.container import Container, Provider
from ghostos.common import Identifiable, EntityType, Identifier
from ghostos.core.session.session import Session, SessionProps
from ghostos.core.session.tasks import GoTaskStruct, TaskState, GoTasks
from ghostos.core.session.events import Event
from ghostos.core.messages import Message


class Ghost(Identifiable, EntityType, Protocol):
    """
    """
    # <moss-ignore>
    # The word `Ghost` is picked from `Ghost In the Shell` movie.
    # The Ghost can perform as both conversational object or an async function.
    # Ghost is the abstract of atomic state machine unit in the GhostOS.
    #
    # for example, llm-based `Agent` is a state machine, an implementation of Ghost in GhostOS.
    #
    # Why Agent is a state machine?
    # 1. Agent receives an event at a time, not parallel, or face brain split.
    # 2. Agent keep it state in the system prompt and messages, by nature language.
    # 3. Agent take actions that matching expectation.
    # So Agent is an AI-State-Machine, defined from prompt, not code; executed by Model, not Interpreter.
    #
    # About the Ghost Abstract:
    # 1. it is a class.
    # 2. the ghost class can construct ghost instance.
    # 3. any ghost instance can run as a conversational task
    # 4. a conversational task runs in turns, receiving event and replying messages.
    # 5. the conversational task is stateful, accept one event at a time.
    # 6. the conversational task reach the end when it is canceled, done or failed
    # 7. all the ghost has a Goal model to describe its current achievement.
    # 8. The Ghost Class shall be simple and clear to the AI models, when they are creating ghosts themselves.
    #
    # and the Most valuable features about ghost are:
    # 1. ghosts shall be fractal, can be called by other ghosts.
    # 2. ghost shall be defined by code, which can be generated by meta-agents.
    # </moss-ignore>

    Goal: ClassVar[Union[Type, None]]
    """ the model of the ghost's goal"""

    __ghost_driver__: Type[GhostDriver] = None


G = TypeVar("G", bound=Ghost)


class GhostDriver(Generic[G], ABC):
    """
    Ghost class is supposed to be a data class without complex methods definitions.
    so it seems much clear when prompt to the LLM or user-level developer.
    when LLM is creating a ghost class or instance, we expect it only see the code we want it to see,
    without knowing the details codes of it, for safety / fewer tokens / more focus or other reasons.

    so the methods of the ghost class defined in this class.
    only core developers should know details about it.
    """

    def __init__(self, ghost: G) -> None:
        self.ghost = ghost

    @abstractmethod
    def create(self, parent_session: Session) -> GoTaskStruct:
        """
        create task in given
        :param parent_session:
        :return:
        """
        pass

    @abstractmethod
    def get_goal(self, session: Session) -> Optional[G.Goal]:
        """
        generate the ghost goal from session_state
        may be the Goal Model is a SessionStateValue that bind to it.

        The AI behind a ghost is not supposed to operate the session object,
        but work on the goal through functions or Moss Injections.
        """
        pass

    @abstractmethod
    def on_event(self, session: Session, event: Event) -> Union[Operator, None]:
        """
        all the state machine is only handling session event with the predefined operators.
        """
        pass


class Operator(Protocol):
    """
    Operator to operating the GhostOS through the Session encapsulation.

    The Operator is just like the primitives of any coding language.
    for example, GhostOS have some operators work like python's `return`, `yield`, `await` .

    I'm not capable to develop a real OS or a new coding language for AI,
    GhostOS is built above python with the additional complexities.

    Operators should be predefined, offer to user-level developer, or AI-models.
    """

    @abstractmethod
    def run(self, session: Session) -> Union[Operator, None]:
        """
        :return: None means stop the loop, otherwise keep going.

        operator returns an operator is a way to encapsulate repetitive codes.
        """
        pass

    @abstractmethod
    def destroy(self):
        """
        Python gc is not trust-worthy
        Especially A keep B, B keep C, C keep A, father and child keep each other.
        I prefer to del the object attributes in the end of the object lifecycle.
        """
        pass


class GhostOS(Protocol):

    @abstractmethod
    def container(self) -> Container:
        """
        root container for GhostOS
        """
        pass

    @abstractmethod
    def connect(
            self,
            shell_id: str = "local",
            process_id: Optional[str] = None,
            properties: Optional[Dict[str, Any]] = None,
            *providers: Provider,
    ) -> Shell:
        """
        The word 'Shell' is picked from `Ghost In the Shell` movie.
        Shell is the body of an AI or something.
        this method create or connect a shell that can communicate with the ghosts inside it.

        :param shell_id: id of the runtime instance keep all the shell level runtime objects.
        :param providers: register shell level providers. only this shell instance have them.
        :param process_id: once a shell instance is recreated,
                           all the process level runtime objects will be abandoned.
                           such as tasks, threads, events etc.
                           but the shell level memory will keep existence.
        :param properties: the properties of the ghost instance, inherited by every task created in the shell.
        :return: a connection to the limbo where all the ghosts running inside
        """
        pass


class Shell(Protocol):
    """
    shell basically is an event loop run all the ghost (agentic State Machine).
    """

    @abstractmethod
    def container(self) -> Container:
        """
        shell has its own container with providers.
        in case ghostos start multiple shell at same time
        """
        pass

    @abstractmethod
    def send_event(self, event: Event) -> None:
        """
        send an event into the loop.
        the event always has a task_id, so the task shall be created first.
        """
        pass

    @abstractmethod
    def quit(self):
        """
        quit the shell connection.
        """
        pass

    @abstractmethod
    def get_task(self, task_id: str, lock: bool) -> Optional[GoTaskStruct]:
        """
        get a task instance by id
        :param task_id:
        :param lock: if True, try to lock the task before getting.
        :return: None if the task is not exists or is locked.
        """
        pass

    @abstractmethod
    def sync_task(self, task_id: str) -> Optional[Conversation]:
        """
        lock a task then create a conversation.
        :param task_id:
        :return:
        """
        pass

    @abstractmethod
    def sync(self, ghost: Ghost) -> Conversation:
        """
        create a top-level conversation with a ghost.
        top-level means task depth is 0.
        So it never locked until the conversation is created.
        :param ghost:
        :return:
        """
        pass

    @abstractmethod
    def create_task(self, ghost: Ghost, parent_task: Optional[str] = None) -> GoTaskStruct:
        pass

    @abstractmethod
    def run_task(
            self,
            task_id: str,
            timeout: float = 0.0,
            loop: int = 0,
    ) -> Union[Any, TaskState]:
        """
        run a task until it is end. which means:
        - reach timeout
        - reach max loop times
        - state is Done, Canceled, or Failed.

        :param task_id: use task_id to lock the task before running. if failed, raise  TaskIsLockedError
        :param timeout:
        :param loop:
        :return:
        """
        pass

    @abstractmethod
    def run_ghost(
            self,
            ghost: Ghost, *,
            timeout: float = 0.0,
            loop: int = 0,
    ) -> Union[Any, TaskState]:
        """
        run a ghost task until it stopped,
        :param ghost: the ghost is used to generate a task, actually.
        :param timeout: if timeout > 0, throw TimeoutError after timeout.
        :param loop: how many times to run the ghost event loop. < 1 means no limitations.
        :return: [Ghost.Goal, TaskState]
        """
        pass

    @abstractmethod
    def background_run(
            self,
            *,
            timeout: float = 0.0,
            max_events_handling: int = 0,
            stop_check: Optional[Callable[[], bool]] = None,
    ):
        """
        run the event loop for the ghosts in the Shell.
        loop is:
          1. pop task notification.
          2. try to converse the task
          3. if failed, pop another task notification.
          4. if success, pop task event and handle it until no event found.
          5. send a task notification after handling, make sure someone check the task events are empty.
        only the tasks that depth > 0 have notifications.
        background run itself is blocking method, run it in a separate thread for parallel execution.
        :param timeout:
        :param max_events_handling:
        :param stop_check: check stop signal from outside function.
        :return:
        """
        pass


class Conversation(Protocol):
    """
    interface for operate on synchronized (task is locked) ghost
    """

    @abstractmethod
    def ghost(self) -> Ghost:
        pass

    @abstractmethod
    def session(self) -> Session:
        pass

    @abstractmethod
    def is_done(self) -> bool:
        pass

    @abstractmethod
    def create_response(self, inputs: Iterable[Message]) -> Iterable[Message]:
        pass

    @abstractmethod
    def handle_event(self, event: Event) -> Iterable[Message]:
        pass

    @abstractmethod
    def pop_event(self, event: Event) -> Optional[Event]:
        pass

    @abstractmethod
    def fail(self, error: Exception) -> bool:
        pass

    @abstractmethod
    def close(self):
        pass

    @abstractmethod
    def closed(self) -> bool:
        pass

    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        if exc_val is not None:
            return self.fail(exc_val)
        else:
            self.close()
            return None
