from typing import Optional, Generic, TypeVar, Iterable, Callable, Tuple, Union, List, Type
from typing_extensions import Literal, Self
from abc import ABC, abstractmethod
from ghostos.container import Container
from ghostos.core.ghosts import (
    Ghost, GhostConf, Inputs,
    Shell, Thought
)
from ghostos.core.runtime import (
    Event,
    GoProcess,
    GoTaskStruct, GoTasks,
    GoThreadInfo, GoThreads,
    EventBus,
)
from ghostos.core.messages import (
    Stream, Message, Received,
)


class Host(ABC):
    """
    An instance of a bot or an agent.
    Composed by a shell and the ghost.
    """

    @abstractmethod
    def process(self) -> GoProcess:
        """
        process of the host instance.
        """
        pass

    @abstractmethod
    def conf(self) -> GhostConf:
        """
        ghost conf to generate a ghost instance
        """
        pass

    @abstractmethod
    def shell(self) -> Shell:
        """
        the shell of the Host
        """
        pass

    @abstractmethod
    def send_event(self, event: Event) -> None:
        """
        send an event to the ghost, but not handle it immediately
        """
        pass

    @abstractmethod
    def task(self, task_id: Optional[str] = None) -> Optional[GoTaskStruct]:
        pass

    @abstractmethod
    def tasks(self) -> GoTasks:
        pass

    @abstractmethod
    def thread(self, task_id: Optional[str] = None) -> Optional[GoThreadInfo]:
        pass

    @abstractmethod
    def history(self, task_id: Optional[str] = None) -> Optional[List[Message]]:
        pass

    @abstractmethod
    def threads(self) -> GoThreads:
        pass


class Run(ABC):
    @abstractmethod
    def task(self) -> GoTaskStruct:
        pass

    @abstractmethod
    def host(self) -> Host:
        pass

    @abstractmethod
    def is_main_task(self) -> bool:
        pass

    @abstractmethod
    def event(self) -> Event:
        pass

    @abstractmethod
    def thought(self) -> None:
        pass

    @abstractmethod
    def receive(self) -> Iterable[Received]:
        pass

    @abstractmethod
    def stop(self, wait: bool = True, *, cancel_futures: bool = False) -> None:
        """
        :param wait:
        :param cancel_futures:
        :return:
        """
        pass


class Runner(ABC):
    """
    Is a way to run host's tasks.
    You can either use it synchronously by run-frame in a controlled loop;
    or asynchronously by loop_util_stop function.
    """

    @abstractmethod
    def run_frame(self) -> Optional[Run]:
        """
        run a single frame of background tasks,
        one frame means a task handle one event.
        :return: a Run instance that can retrieve the messages. stop is useless
        """
        pass

    @abstractmethod
    def loop_until_stop(
            self,
            on_run: Callable[[Run], None],
            on_error: Callable[[Run, Exception], None],
            stop: Optional[Callable[[], bool]] = None,
            worker: int = 4,
            idle: float = -1,
    ) -> None:
        """
        block the main loop, run background task frame until stop is called.
        the actual logic is:
        1. pop task notification from eventbus, if none, idle or stop
        2. lock the task, if failed, drop the notification and go on popping.
        3. consume task event from eventbus
        4. if event is None, go on popping task notification
        5. if event exists, run a task frame with the event and callback function.
        6. checkpoint: check stop condition
        7. redirect to step 1

        :param on_run: when a Run is generated by some task, event.
               can do something, like push message to someone
        :param on_error: usually log error, or stop everything by run.stop()
        :param stop: stop condition callback. if return True, the loop will stop at checkpoint.
        :param worker: concurrent worker number.
        :param idle: if no work to do, idle a while, in seconds. if negative, the loop stop when in idle.
        :return: block the main loop. or you can call this function in another thread.
        """
        pass


class HostRunner(Runner, ABC):
    @abstractmethod
    def host(self) -> Host:
        """
        host runner can get to the host instance.
        """
        pass

    @abstractmethod
    def send_inputs(
            self,
            inputs: Inputs,
            *,
            mod: Literal["block", "queue", "intercept"] = "block",
            timeout: float = 2,
    ) -> Optional[Run]:
        """
        send inputs to the ghost main task and try to create a synchronize response.
        the inputs will be filtered by main task's thought, to generate an event or intercept it.
        then the main task will execute a frame immediately, and return a Run instance.

        if another process lock the main task, the `mod` decide the following actions.

        :param inputs: the unparsed inputs.
        :param mod:
           - block: if the main task is locked, retry until the timeout is reached, then return with error message.
           - queue: if the main task is locked and timeout, send an asynchronize event, and return None
           - intercept: if the main task is locked and timeout, force to lock the main task, intercept other run.
        :param timeout: timeout in second, before the main task's locker required.
        :return: if locked the main task, run a frame and return a Run instance.
        """
        pass

    @abstractmethod
    def run_task_frame(self, task_id: Optional[str] = None) -> Optional[Run]:
        """
        run a background task frame manually
        :param task_id: if task_id is None, pop a task notification from eventbus.
        :return: if run is None, means no event found or lock task failed.
        """
        pass


class GhostOS(ABC):

    @abstractmethod
    def container(self) -> Container:
        pass

    @abstractmethod
    def register(self, conf: GhostConf) -> None:
        pass

    @abstractmethod
    def forge(
            self,
            shell: Shell,
            ghost_id: Union[str, GhostConf],
    ) -> Host:
        """
        build a Host (robot or agent) with it shell (body) and ghost (brain).
        shell id is the session id of the ghost.
        :param shell:
        :param ghost_id:
        :return:
        :exception: NotImplementedError if the ghost_id is not registered
        """
        pass

    @abstractmethod
    def send_event(self, event: Event) -> None:
        """
        send an async event to the system.
        shall be handled by background run.
        """
        pass

    @abstractmethod
    def create_runner(self) -> Runner:
        """
        create a background runner for all the tasks in this ghostos system.
        """
        pass

    @abstractmethod
    def create_host_runner(
            self,
            shell: Shell,
            ghost_id: Union[str, GhostConf],
            process_id: Optional[str] = None,
    ) -> HostRunner:
        """
        create a host runner that has its own process eventbus.
        only host runner can receive its task events.
        :param shell:
        :param ghost_id:
        :param process_id: the specific process id,
        :return:
        """
        pass
